<!-- XHTML 1.0 Strict -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<meta name="author" content="Rachid Touzani" />
<meta name="keywords" content=" css, dropdowns, dropdown menu, drop-down, menu, navigation, nav, horizontal, vertical left-to-right, vertical right-to-left, horizontal linear, horizontal upwards, cross browser, internet explorer, ie, firefox, safari, opera, browser, lwis" />
<meta name="description" content="Clean, standards-friendly, modular framework for dropdown menus" />
<link href="../css/dropdown.vertical.css" media="screen" rel="stylesheet" type="text/css" />
<link href="../css/default.ultimate.css" media="screen" rel="stylesheet" type="text/css" />

<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Lesson 4</title>
<link rel="stylesheet" type="text/css" href="../doxygen.css" />
<link rel="stylesheet" type="text/css" href="../tabs.css"  />
</head>

<body bgcolor="#FFFFFF" link="#FF0000" vlink="#FF00FF" alink="#FF00FF">
<p align="center"><a href="../index.html"><img src="../im/ofeli.gif" width="150" border="0"></a></p>

<center>
  <div id="cse" style="width: 60%;">Loading</div>
  <script src="http://www.google.com/jsapi" type="text/javascript"></script>
  <script type="text/javascript"> 
     google.load('search', '1', {language : 'en', style : google.loader.themes.SHINY});
     google.setOnLoadCallback(function() {
        var customSearchOptions = {};  var customSearchControl = new google.search.CustomSearchControl(
        '012396140824982761142:-qrywxcfi_o', customSearchOptions);
        customSearchControl.setResultSetSize(google.search.Search.FILTERED_CSE_RESULTSET);
        customSearchControl.draw('cse');
     }, true);
   </script>
   <style type="text/css">
     .gsc-control-cse {
     font-family: Verdana, sans-serif;
     border-color: #DAE0E5;
     background-color: #DAE0E5;
   }
   .gsc-control-cse .gsc-table-result { font-family: Verdana, sans-serif; }
   input.gsc-input { border-color: #B6BEC5; }
   input.gsc-search-button {
     border-color: #B6BEC5;
     background-color: #D0D1D4;
   }
   .gsc-tabHeader.gsc-tabhInactive {
     border-color: #999999;
     background-color: #EEEEEE;
   }
   .gsc-tabHeader.gsc-tabhActive {
     border-color: #999999;
     background-color: #999999;
   }
   .gsc-tabsArea { border-color: #999999; }
   .gsc-webResult.gsc-result,
   .gsc-results .gsc-imageResult {
     border-color: #FFFFFF;
     background-color: #FFFFFF;
   }
   .gsc-webResult.gsc-result:hover,
   .gsc-imageResult:hover {
     border-color: #D2D6DC;
     background-color: #EDEDED;
   }
   .gsc-webResult.gsc-result.gsc-promotion:hover {
     border-color: #D2D6DC;
     background-color: #EDEDED;
   }
   .gs-webResult.gs-result a.gs-title:link,
   .gs-webResult.gs-result a.gs-title:link b,
   .gs-imageResult a.gs-title:link,
   .gs-imageResult a.gs-title:link b { color: #0568CD; }
   .gs-webResult.gs-result a.gs-title:visited,
   .gs-webResult.gs-result a.gs-title:visited b,
   .gs-imageResult a.gs-title:visited,
   .gs-imageResult a.gs-title:visited b { color: #0568CD; }
   .gs-webResult.gs-result a.gs-title:hover,
   .gs-webResult.gs-result a.gs-title:hover b,
   .gs-imageResult a.gs-title:hover,
   .gs-imageResult a.gs-title:hover b { color: #0568CD; }
   .gs-webResult.gs-result a.gs-title:active,
   .gs-webResult.gs-result a.gs-title:active b,
   .gs-imageResult a.gs-title:active,
   .gs-imageResult a.gs-title:active b { color: #0568CD; }
   .gsc-cursor-page { color: #0568CD; }
   a.gsc-trailing-more-results:link { color: #0568CD; }
   .gs-webResult .gs-snippet,
   .gs-imageResult .gs-snippet,
   .gs-fileFormatType { color: #5F6A73; }
   .gs-webResult div.gs-visibleUrl,
   .gs-imageResult div.gs-visibleUrl { color: #5F6A73; }
   .gs-webResult div.gs-visibleUrl-short { color: #5F6A73; }
   .gs-webResult div.gs-visibleUrl-short { display: none; }
   .gs-webResult div.gs-visibleUrl-long { display: block; }
   .gs-promotion div.gs-visibleUrl-short { display: none; }
   .gs-promotion div.gs-visibleUrl-long { display: block; }
   .gsc-cursor-box { border-color: #FFFFFF; }
   .gsc-results .gsc-cursor-box .gsc-cursor-page {
      border-color: #999999;
      background-color: #FFFFFF;
      color: #0568CD;
   }
   .gsc-results .gsc-cursor-box .gsc-cursor-current-page {
      border-color: #999999;
      background-color: #999999;
      color: #0568CD;
   }
   .gsc-webResult.gsc-result.gsc-promotion {
      border-color: #D2D6DC;
      background-color: #D0D1D4;
   }
   .gsc-completion-title { color: #0568CD; }
   .gsc-completion-snippet { color: #5F6A73; }
   .gs-promotion a.gs-title:link,
   .gs-promotion a.gs-title:link *,
   .gs-promotion .gs-snippet a:link { color: #0066CC; }
   .gs-promotion a.gs-title:visited,
   .gs-promotion a.gs-title:visited *,
   .gs-promotion .gs-snippet a:visited { color: #0066CC; }
   .gs-promotion a.gs-title:hover,
   .gs-promotion a.gs-title:hover *,
   .gs-promotion .gs-snippet a:hover { color: #0066CC; }
   .gs-promotion a.gs-title:active,
   .gs-promotion a.gs-title:active *,
   .gs-promotion .gs-snippet a:active { color: #0066CC; }
   .gs-promotion .gs-snippet,
   .gs-promotion .gs-title .gs-promotion-title-right,
   .gs-promotion .gs-title .gs-promotion-title-right *  { color: #333333; }
   .gs-promotion .gs-visibleUrl,
   .gs-promotion .gs-visibleUrl-short { color: #5F6A73; }
   </style>
</center>
</p>

<div id="mainmenu">
<div class="text">

 <div class="tabs">
   <ul class="tablist">
   <li><a href="../index.html"><span>Home</span></a>
   <li><a href="../overview.html"><span>Overview</span></a>
   <li><a href="../html/index.html"><span>Class Documentation</span></a>
   <li><a href="../fformats.html"><span>File Formats</span></a>
   <li class="current"><a href="../tutorial.html"><span>Tutorial</span></a>
   <li><a href="../demos.html"><span>Demo Codes</span></a>
   </ul>
 </div>

</div>
</div>

&nbsp;
<p>
<h2>Lesson 4: A time-dependent problem</h2>

<p>
<table border="2" cellpadding="2" cellspacing="0" >
<tr>
<td align="center" width="35"><a href="lesson3.html"><img src="../im/backward.gif" border="0"></a></td>
<td align="center" width="35"><a href="../tutorial.html"><img src="../im/top.gif" border="0"></a></td>
<td align="center" width="35"><a href="lesson5.html"><img src="../im/forward.gif" border="0"></a></td>
</tr>
</table>
</p>

<p>
<span class=TEXT>We introduce, in this lesson, new aspects of <span class=LOGO>OFELI</span> programmation:</span>
<ul type="square">
<span class=TEXT>
<li>We consider a time-dependent heat transfer problem that we solve by Backward Euler time stepping scheme.
<li>We consider the case of Neumann Boundary conditions.
<li>Data (problem parameters) are introduced by a data file using <a href="../html/classOFELI_1_1IPF.html">IPF</a> format.
</span>
</ul>
</p>

<p class=EL>The Finite Element Code</p>

<h4><span class=text><font color="red">The main program</font></span></h4>

<SPAN class=TEXT><SPAN class=TEXT>Here is a description of the source code. The source file can be found
in Example 4 in the <span class=VAR>examples</span> directory.</span>

<ul type="square">
<li><SPAN class=TEXT>We start, as usual, by including required headers and naming the appropriate namespace.</span>
<p><table bgcolor="#e0f8f7" border="1" frame=box rules=none width=700>
<tr><td>
<pre><font color="blue" size=3>#include "OFELI.h"
#include "Therm.h"
using namespace OFELI;</font></pre>
</td></tr></table>
</span></p>

<li><SPAN class=TEXT>The program will have as argument the name of the parameter data file:
<p><table bgcolor="#e0f8f7" border="1" frame=box rules=none width=700>
<tr><td>
<pre><font color="blue" size=3>int main(int argc, char *argv[])
{</font></pre>
</td></tr></table>
</span></p>

<li><SPAN class=TEXT>We expand program arguments and declare an instance of class <a href="../html/classOFELI_1_1IPF.html">IPF</a> for parameter
file:
<p><table bgcolor="#e0f8f7" border="1" frame=box rules=none width=700>
<tr><td>
<pre><font color="blue" size=3>   if (argc &lt;= 1) {
      cout &lt;&lt; " Usage: lesson4 &lt;parameter_file&gt;" &lt;&lt; endl;
      exit(1)
   }
   IPF data(argv[1]);</font></pre>
</td></tr></table>
</span></p>

<li><SPAN class=TEXT>Time integration parameters are retrieved as <span class=TT>IPF</span> class members. These data are stored in global variables of <span class=LOGO>OFELI</span>
which are <span class=TT>theFinalTime</span> and <span class=TT>theTimeStep</span>.
<p><table bgcolor="#e0f8f7" border="1" frame=box rules=none width=700>
<tr><td>
<pre><font color="blue" size=3>   theFinalTime = data.getMaxTime();
   theTimeStep = data.getTimeStep();</font></pre>
</td></tr></table>
</span></p>
<li><span class=TEXT>The mesh instance is constructed by giving the mesh file.</span>
<p><table bgcolor="#e0f8f7" border="1" frame=box rules=none width=700>
<tr><td>
<pre><font color="blue" size=3>   Mesh ms(data.getMeshFile());</font></pre>
</td></tr></table></p>
<li><span class=TEXT>In the present example, we introduce boundary conditions through a user defined class. This may be
optional for Dirichlet conditions but necessary for Neumann ones.
<p><table bgcolor="#e0f8f7" border="1" frame=box rules=none width=700>
<tr><td>
<pre><font color="blue" size=3>   User ud(ms);</font></pre>
</td></tr></table></p>
<p>Implementation of class <span class=TT>User</span> will be given later.</span>
<li><span class=TEXT>We declare matrix and vector data: first, the matrix <span class=TT>A</span> is declared
as instance of class <span class=TT><a href="../html/classOFELI_1_1SkSMatrix.html">SkSMatrix</a></span>. The vectors <span class=TT>b</span>,
<span class=TT>u</span> and <span class=TT>bc</span> will contain respectively, alternatively the right-hand side
and the current solution, the previous solution and prescribed Dirichlet boundary conditions.
<p><table bgcolor="#e0f8f7" border="1" frame=box rules=none width=700>
<tr><td>
<pre><font color="blue" size=3>   SkSMatrix&lt;double&gt; A(ms);
   Vect&lt;double&gt; b(ms.getNbDOF()), u(ms.getNbDOF()), bc(ms.getNbDOF());
</font></pre>
</td></tr></table>
</span></p>
<li><span class=TEXT>Since, we are dealing with a transient problem, we need initial data. This is retrieved
from class member <span class=TT>setInitialData</span> of class <span class=TT>User</span> :
<p><table bgcolor="#e0f8f7" border="1" frame=box rules=none width=700>
<tr><td>
<pre><font color="blue" size=3>   ud.setInitialData(u);</font></pre>
</td></tr></table>
</span></p>
<li><span class=TEXT>We start a loop over time steps. For this we use a macro defined
in <span class=LOGO>OFELI</span>: <span class=TT>TimeLoop</span> stands for
a loop over time steps, that updates both time value (global variable
<span class=TT>theTime</span>) and the step index (global variable
<span class=TT>theStep</span>): 
<p><table bgcolor="#e0f8f7" border="1" frame=box rules=none width=700>
<tr><td>
<pre><font color="blue" size=3>   TimeLoop {</font></pre>
</td></tr></table>
</span></p>
<li><span class=TEXT>The first thing to do here is to update time value and initialize the right-hand side
to zero since this one will be assembled.
<p><table bgcolor="#e0f8f7" border="1" frame=box rules=none width=700>
<tr><td>
<pre><font color="blue" size=3>      b = 0;</font></pre>
</td></tr></table>
</span></p>
<li><span class=TEXT>We next transmit the user data class instance <span class=TT>ud</span> the time value:
<p><table bgcolor="#e0f8f7" border="1" frame=box rules=none width=700>
<tr><td>
<pre><font color="blue" size=3>      ud.setTime(theTime);</font></pre>
</td></tr></table>
</span>
<li><span class=TEXT>In order to deal with a problem with time-dependent boundary condition we re-fill vector
<span class=TT>bc</span> at this level.
<p><table bgcolor="#e0f8f7" border="1" frame=box rules=none width=700>
<tr><td>
<pre><font color="blue" size=3>      ud.setDBC(bc);</font></pre>
</td></tr></table>
</span></p>
<li><span class=TEXT>We write a loop over finite elements as in the previous lessons:
<p><table bgcolor="#e0f8f7" border="1" frame=box rules=none width=700>
<tr><td>
<pre><font color="blue" size=3>      MeshElements(ms) {</font></pre>
</td></tr></table>
</span></p>
<li><span class=TEXT>We use here class <a href="../html/classOFELI_1_1DC2DT3.html">DC2DT3</a> with the constructor that
involves time. Instance <span class=TT>eq</span> will then be used to build matrix and right-hand side.
<p><table bgcolor="#e0f8f7" border="1" frame=box rules=none width=700>
<tr><td>
<pre><font color="blue" size=3>         DC2DT3 eq(theElement,u,theTime);</font></pre>
</td></tr></table>
</span></p>
<li><span class=TEXT>The element matrix is constructed with capacity term (chosen here to be lumped) and
diffusion term:
<p><table bgcolor="#e0f8f7" border="1" frame=box rules=none width=700>
<tr><td>
<pre><font color="blue" size=3>         eq.LCapacity(1./theTimeStep);
         eq.Diffusion();</font></pre>
</td></tr></table></p>

<p>Note that capacity matrix is multiplied by the inverse of time step. This is necessary to implement the backward
Euler scheme.</span>
<li><span class=TEXT>We assemble matrix and right-hand side (useless for the present example). Note that, since
the matrix does not depend on time, it is assembled once and factorized once.
<p><table bgcolor="#e0f8f7" border="1" frame=box rules=none width=700>
<tr><td>
<pre><font color="blue" size=3>         if (theStep==1)
            eq.ElementAssembly(A);
         eq.ElementAssembly(b);
      }</font></pre>
</td></tr></table></p>
<p>The loop on elements is closed.</span>
<li><span class=TEXT>To deal with Neumann boundary conditions (involving boundary integrals), we have to loop
over given sides. The loop looks like the one over elements:
<p><table bgcolor="#e0f8f7" border="1" frame=box rules=none width=700>
<tr><td>
<pre><font color="blue" size=3>      MeshSides(ms) {</font></pre></td></tr></table>
</span></p>
<li><span class=TEXT>For each side (pointed by <span class=TT>eq</span>) we invoke a constructor that involves sides.
<p><table bgcolor="#e0f8f7" border="1" frame=box rules=none width=700>
<tr><td>
<pre><font color="blue" size=3>         DC2DT3 eq(theSide,u,theTime);</font></pre>
</td></tr></table>
</span></p>
<li><span class=TEXT>We fill the side vector using the instance <span class=TT>ud</span> of class <span class=TT>User</span>.
The function <span class=TT>BoundaryRHS</span> calculates the side integral.
<p><table bgcolor="#e0f8f7" border="1" frame=box rules=none width=700>
<tr><td>
<pre><font color="blue" size=3>         eq.BoundaryRHS(ud);</font></pre>
</td></tr></table>
</span></p>
<li><span class=TEXT>We assemble side vectors just like for elements and close the loop.
<p><table bgcolor="#e0f8f7" border="1" frame=box rules=none width=700>
<tr><td>
<pre><font color="blue" size=3>         eq.SideAssembly(b);
      }</font></pre>
</td></tr></table>
</span></p>
<li><span class=TEXT>Once the linear system is assembled, we impose Dirichlet boundary conditions by a penalty
techniques implemented in member function <span class=TT>Prescribe</span>:
<p><table bgcolor="#e0f8f7" border="1" frame=box rules=none width=700>
<tr><td>
<pre><font color="blue" size=3>      A.Prescribe(b,bc,theStep-1);</font></pre>
</td></tr></table>
</span></p>
<li><span class=TEXT>As said before, factorization is carried out at
the first time step only. Obviously, solution is
called each time step.
<p><table bgcolor="#e0f8f7" border="1" frame=box rules=none width=700>
<tr><td>
<pre><font color="blue" size=3>      A.solve(b);</font></pre>
</td></tr></table>
</span></p>
<li><span class=TEXT>Now, vector <span class=TT>b</span> contains the solution. We copy it to <span class=TT>u</span>
to store it as a previous solution.
<p><table bgcolor="#e0f8f7" border="1" frame=box rules=none width=700>
<tr><td>
<pre><font color="blue" size=3>      u = b;</font></pre>
</td></tr></table>
</span>
<li><span class=TEXT>We may want to output the solution each time step:
<p><table bgcolor="#e0f8f7" border="1" frame=box rules=none width=700>
<tr><td>
<pre><font color="blue" size=3>      cout &lt;&lt; "\nSolution for time: " &lt;&lt; time &lt;&lt; endl &lt;&lt; u;
   }
   return 0;
}</font></pre>
</td></tr></table></p>
<p>and then close the time stepping loop and the program.</span>
</ul>

<h4><font color="red">A user defined class</font></h4>

<span class=text>We have now to implement class <span class=TT>User</span> that defines boundary conditions,
initial conditions. The class is defined in file <span class=TT>User.h</span>
in the Example 4 in the <span class=TT>tutorial</span> directory.</span>

<ul type="square">
<li><span class=TEXT>Of course, we start by including file <span class=TT>OFELI.h</span> and invoking the namespace:
<p><table bgcolor="#e0f8f7" border="1" frame=box rules=none width=700>
<tr><td>
<pre><font color="blue" size=3>#include "OFELI.h"
using namespace OFELI;</font></pre>
</td></tr></table>
</span></p>
<li><span class=TEXT>Class <span class=TT>User</span> derives from abstract class <a href="../html/classOFELI_1_1UserData.html">UserData</a>.
<p><table bgcolor="#e0f8f7" border="1" frame=box rules=none width=700>
<tr><td>
<pre><font color="blue" size=3>class User : public UserData&lt;double&gt; {</font></pre>
</td></tr></table>
</span></p>
<li><span class=TEXT>This class has only public members and no attributes.
<p><table bgcolor="#e0f8f7" border="1" frame=box rules=none width=700>
<tr><td>
<pre><font color="blue" size=3>public :</font></pre>
</td></tr></table>
</span></p>
<li><span class=TEXT>We have a constructor that provides the mesh to the class : nothing to do, the parent
class does the job for you.
<p><table bgcolor="#e0f8f7" border="1" frame=box rules=none width=700>
<tr><td>
<pre><font color="blue" size=3>   User(Mesh &mesh) : UserData&lt;double&gt;(mesh) { }</font></pre>
</td></tr></table>
</span></p>
<li><span class=TEXT>We define a member class to give a value to prescribe for boundary condition in function
of node code, node coordinates, time value and degree of freedom: Here, we impose that a code <span class=TT>2</span>
imposes the value <span class=TT>1.0</span>. Any other code will impose the default value <span class=TT>0.0</span>.
<p><table bgcolor="#e0f8f7" border="1" frame=box rules=none width=700>
<tr><td>
<pre><font color="blue" size=3>   double BoundaryCondition(const Point&lt;double&gt; &x, int code, double time=0., size_t dof=1)
   {
      double ret = 0.0;
      if (code == 2)
         ret = 1.0;
      return ret;
   }</font></pre>
</td></tr></table>
</span></p>
<li><span class=TEXT>The same scheme works for Neumann boundary condition:
<p><table bgcolor="#e0f8f7" border="1" frame=box rules=none width=700>
<tr><td>
<pre><font color="blue" size=3>   double SurfaceForce(const Point&lt;double&gt; &x, int code, double time, size_t dof)
   {
      if (code)
         return 1.0;
      else
         return 0.0;
   }
</font></pre>
</td></tr></table>
</span></p>
<li><span class=TEXT>The class definition ends here
<p><table bgcolor="#e0f8f7" border="1" frame=box rules=none width=700>
<tr><td>
<pre><font color="blue" size=3>};</font></pre>
</td></tr></table></p>
<li><span class=TEXT>Let us finally note that since no implementation is given for initial condition,
the default one is <span class=TT>0.0</span> for each degree of freedom.</span>
</ul></p>

<p class=EL>A test</p>

<p><SPAN class=TEXT>We use here exactly the same mesh file as in the previous lesson. Of course, we obtain the same solution.
The convergence is obtained after 3 iterations.</span>

<p><table align="center" border="2" cellpadding="2" cellspacing="0" >
<tr>
<td align="center" width="35"><a href="lesson3.html"><img src="../im/backward.gif" border="0"></a></td>
<td align="center" width="35"><a href="../tutorial.html"><img src="../im/top.gif" border="0"></a></td>
<td align="center" width="35"><a href="lesson5.html"><img src="../im/forward.gif" border="0"></a></td>
</tr>
</table>

&nbsp;
<div id="foot_bar">
   Copyright &copy; 1998-2016 Rachid Touzani&nbsp;
</div>

</body>
</html>
